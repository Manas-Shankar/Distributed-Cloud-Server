// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: recovery.proto
#ifndef GRPC_recovery_2eproto__INCLUDED
#define GRPC_recovery_2eproto__INCLUDED

#include "recovery.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace recovery {

// Service definition
class RecoveryService final {
 public:
  static constexpr char const* service_full_name() {
    return "recovery.RecoveryService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // starts recovery process and returns the neccessary data for recovery in crashed node
    virtual ::grpc::Status StartRecovery(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest& request, ::recovery::StartRecoveryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::StartRecoveryResponse>> AsyncStartRecovery(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::StartRecoveryResponse>>(AsyncStartRecoveryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::StartRecoveryResponse>> PrepareAsyncStartRecovery(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::StartRecoveryResponse>>(PrepareAsyncStartRecoveryRaw(context, request, cq));
    }
    // get log files from primary
    virtual ::grpc::Status GetLogFiles(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest& request, ::recovery::LogFiles* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::LogFiles>> AsyncGetLogFiles(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::LogFiles>>(AsyncGetLogFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::LogFiles>> PrepareAsyncGetLogFiles(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::LogFiles>>(PrepareAsyncGetLogFilesRaw(context, request, cq));
    }
    // client requests checkpoint data from server to signal client is ready
    virtual ::grpc::Status GetCheckpointFiles(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest& request, ::recovery::CheckpointFilesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointFilesResponse>> AsyncGetCheckpointFiles(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointFilesResponse>>(AsyncGetCheckpointFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointFilesResponse>> PrepareAsyncGetCheckpointFiles(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointFilesResponse>>(PrepareAsyncGetCheckpointFilesRaw(context, request, cq));
    }
    // send CheckpointChunks one by one from server to client
    virtual ::grpc::Status SendCheckpointChunk(::grpc::ClientContext* context, const ::recovery::FileChunk& request, ::recovery::CheckpointChunkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointChunkResponse>> AsyncSendCheckpointChunk(::grpc::ClientContext* context, const ::recovery::FileChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointChunkResponse>>(AsyncSendCheckpointChunkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointChunkResponse>> PrepareAsyncSendCheckpointChunk(::grpc::ClientContext* context, const ::recovery::FileChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointChunkResponse>>(PrepareAsyncSendCheckpointChunkRaw(context, request, cq));
    }
    // notify other nodes the checkpointing is complete
    virtual ::grpc::Status NotifyRecoveryComplete(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest& request, ::recovery::RecoveryCompleteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::RecoveryCompleteResponse>> AsyncNotifyRecoveryComplete(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::RecoveryCompleteResponse>>(AsyncNotifyRecoveryCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::RecoveryCompleteResponse>> PrepareAsyncNotifyRecoveryComplete(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::recovery::RecoveryCompleteResponse>>(PrepareAsyncNotifyRecoveryCompleteRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // starts recovery process and returns the neccessary data for recovery in crashed node
      virtual void StartRecovery(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest* request, ::recovery::StartRecoveryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StartRecovery(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest* request, ::recovery::StartRecoveryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // get log files from primary
      virtual void GetLogFiles(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest* request, ::recovery::LogFiles* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetLogFiles(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest* request, ::recovery::LogFiles* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // client requests checkpoint data from server to signal client is ready
      virtual void GetCheckpointFiles(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest* request, ::recovery::CheckpointFilesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCheckpointFiles(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest* request, ::recovery::CheckpointFilesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // send CheckpointChunks one by one from server to client
      virtual void SendCheckpointChunk(::grpc::ClientContext* context, const ::recovery::FileChunk* request, ::recovery::CheckpointChunkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SendCheckpointChunk(::grpc::ClientContext* context, const ::recovery::FileChunk* request, ::recovery::CheckpointChunkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // notify other nodes the checkpointing is complete
      virtual void NotifyRecoveryComplete(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest* request, ::recovery::RecoveryCompleteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void NotifyRecoveryComplete(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest* request, ::recovery::RecoveryCompleteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::recovery::StartRecoveryResponse>* AsyncStartRecoveryRaw(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::recovery::StartRecoveryResponse>* PrepareAsyncStartRecoveryRaw(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::recovery::LogFiles>* AsyncGetLogFilesRaw(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::recovery::LogFiles>* PrepareAsyncGetLogFilesRaw(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointFilesResponse>* AsyncGetCheckpointFilesRaw(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointFilesResponse>* PrepareAsyncGetCheckpointFilesRaw(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointChunkResponse>* AsyncSendCheckpointChunkRaw(::grpc::ClientContext* context, const ::recovery::FileChunk& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::recovery::CheckpointChunkResponse>* PrepareAsyncSendCheckpointChunkRaw(::grpc::ClientContext* context, const ::recovery::FileChunk& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::recovery::RecoveryCompleteResponse>* AsyncNotifyRecoveryCompleteRaw(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::recovery::RecoveryCompleteResponse>* PrepareAsyncNotifyRecoveryCompleteRaw(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status StartRecovery(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest& request, ::recovery::StartRecoveryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::StartRecoveryResponse>> AsyncStartRecovery(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::StartRecoveryResponse>>(AsyncStartRecoveryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::StartRecoveryResponse>> PrepareAsyncStartRecovery(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::StartRecoveryResponse>>(PrepareAsyncStartRecoveryRaw(context, request, cq));
    }
    ::grpc::Status GetLogFiles(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest& request, ::recovery::LogFiles* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::LogFiles>> AsyncGetLogFiles(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::LogFiles>>(AsyncGetLogFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::LogFiles>> PrepareAsyncGetLogFiles(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::LogFiles>>(PrepareAsyncGetLogFilesRaw(context, request, cq));
    }
    ::grpc::Status GetCheckpointFiles(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest& request, ::recovery::CheckpointFilesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointFilesResponse>> AsyncGetCheckpointFiles(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointFilesResponse>>(AsyncGetCheckpointFilesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointFilesResponse>> PrepareAsyncGetCheckpointFiles(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointFilesResponse>>(PrepareAsyncGetCheckpointFilesRaw(context, request, cq));
    }
    ::grpc::Status SendCheckpointChunk(::grpc::ClientContext* context, const ::recovery::FileChunk& request, ::recovery::CheckpointChunkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointChunkResponse>> AsyncSendCheckpointChunk(::grpc::ClientContext* context, const ::recovery::FileChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointChunkResponse>>(AsyncSendCheckpointChunkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointChunkResponse>> PrepareAsyncSendCheckpointChunk(::grpc::ClientContext* context, const ::recovery::FileChunk& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointChunkResponse>>(PrepareAsyncSendCheckpointChunkRaw(context, request, cq));
    }
    ::grpc::Status NotifyRecoveryComplete(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest& request, ::recovery::RecoveryCompleteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::RecoveryCompleteResponse>> AsyncNotifyRecoveryComplete(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::RecoveryCompleteResponse>>(AsyncNotifyRecoveryCompleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::RecoveryCompleteResponse>> PrepareAsyncNotifyRecoveryComplete(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::recovery::RecoveryCompleteResponse>>(PrepareAsyncNotifyRecoveryCompleteRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void StartRecovery(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest* request, ::recovery::StartRecoveryResponse* response, std::function<void(::grpc::Status)>) override;
      void StartRecovery(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest* request, ::recovery::StartRecoveryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetLogFiles(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest* request, ::recovery::LogFiles* response, std::function<void(::grpc::Status)>) override;
      void GetLogFiles(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest* request, ::recovery::LogFiles* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCheckpointFiles(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest* request, ::recovery::CheckpointFilesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetCheckpointFiles(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest* request, ::recovery::CheckpointFilesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SendCheckpointChunk(::grpc::ClientContext* context, const ::recovery::FileChunk* request, ::recovery::CheckpointChunkResponse* response, std::function<void(::grpc::Status)>) override;
      void SendCheckpointChunk(::grpc::ClientContext* context, const ::recovery::FileChunk* request, ::recovery::CheckpointChunkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void NotifyRecoveryComplete(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest* request, ::recovery::RecoveryCompleteResponse* response, std::function<void(::grpc::Status)>) override;
      void NotifyRecoveryComplete(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest* request, ::recovery::RecoveryCompleteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::recovery::StartRecoveryResponse>* AsyncStartRecoveryRaw(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::recovery::StartRecoveryResponse>* PrepareAsyncStartRecoveryRaw(::grpc::ClientContext* context, const ::recovery::StartRecoveryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::recovery::LogFiles>* AsyncGetLogFilesRaw(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::recovery::LogFiles>* PrepareAsyncGetLogFilesRaw(::grpc::ClientContext* context, const ::recovery::GetLogFilesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointFilesResponse>* AsyncGetCheckpointFilesRaw(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointFilesResponse>* PrepareAsyncGetCheckpointFilesRaw(::grpc::ClientContext* context, const ::recovery::CheckpointFilesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointChunkResponse>* AsyncSendCheckpointChunkRaw(::grpc::ClientContext* context, const ::recovery::FileChunk& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::recovery::CheckpointChunkResponse>* PrepareAsyncSendCheckpointChunkRaw(::grpc::ClientContext* context, const ::recovery::FileChunk& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::recovery::RecoveryCompleteResponse>* AsyncNotifyRecoveryCompleteRaw(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::recovery::RecoveryCompleteResponse>* PrepareAsyncNotifyRecoveryCompleteRaw(::grpc::ClientContext* context, const ::recovery::RecoveryCompleteRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_StartRecovery_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLogFiles_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCheckpointFiles_;
    const ::grpc::internal::RpcMethod rpcmethod_SendCheckpointChunk_;
    const ::grpc::internal::RpcMethod rpcmethod_NotifyRecoveryComplete_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // starts recovery process and returns the neccessary data for recovery in crashed node
    virtual ::grpc::Status StartRecovery(::grpc::ServerContext* context, const ::recovery::StartRecoveryRequest* request, ::recovery::StartRecoveryResponse* response);
    // get log files from primary
    virtual ::grpc::Status GetLogFiles(::grpc::ServerContext* context, const ::recovery::GetLogFilesRequest* request, ::recovery::LogFiles* response);
    // client requests checkpoint data from server to signal client is ready
    virtual ::grpc::Status GetCheckpointFiles(::grpc::ServerContext* context, const ::recovery::CheckpointFilesRequest* request, ::recovery::CheckpointFilesResponse* response);
    // send CheckpointChunks one by one from server to client
    virtual ::grpc::Status SendCheckpointChunk(::grpc::ServerContext* context, const ::recovery::FileChunk* request, ::recovery::CheckpointChunkResponse* response);
    // notify other nodes the checkpointing is complete
    virtual ::grpc::Status NotifyRecoveryComplete(::grpc::ServerContext* context, const ::recovery::RecoveryCompleteRequest* request, ::recovery::RecoveryCompleteResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_StartRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StartRecovery() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_StartRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecovery(::grpc::ServerContext* /*context*/, const ::recovery::StartRecoveryRequest* /*request*/, ::recovery::StartRecoveryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecovery(::grpc::ServerContext* context, ::recovery::StartRecoveryRequest* request, ::grpc::ServerAsyncResponseWriter< ::recovery::StartRecoveryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLogFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLogFiles() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetLogFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogFiles(::grpc::ServerContext* /*context*/, const ::recovery::GetLogFilesRequest* /*request*/, ::recovery::LogFiles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLogFiles(::grpc::ServerContext* context, ::recovery::GetLogFilesRequest* request, ::grpc::ServerAsyncResponseWriter< ::recovery::LogFiles>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCheckpointFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCheckpointFiles() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetCheckpointFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCheckpointFiles(::grpc::ServerContext* /*context*/, const ::recovery::CheckpointFilesRequest* /*request*/, ::recovery::CheckpointFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCheckpointFiles(::grpc::ServerContext* context, ::recovery::CheckpointFilesRequest* request, ::grpc::ServerAsyncResponseWriter< ::recovery::CheckpointFilesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendCheckpointChunk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendCheckpointChunk() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_SendCheckpointChunk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCheckpointChunk(::grpc::ServerContext* /*context*/, const ::recovery::FileChunk* /*request*/, ::recovery::CheckpointChunkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendCheckpointChunk(::grpc::ServerContext* context, ::recovery::FileChunk* request, ::grpc::ServerAsyncResponseWriter< ::recovery::CheckpointChunkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NotifyRecoveryComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NotifyRecoveryComplete() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_NotifyRecoveryComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyRecoveryComplete(::grpc::ServerContext* /*context*/, const ::recovery::RecoveryCompleteRequest* /*request*/, ::recovery::RecoveryCompleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNotifyRecoveryComplete(::grpc::ServerContext* context, ::recovery::RecoveryCompleteRequest* request, ::grpc::ServerAsyncResponseWriter< ::recovery::RecoveryCompleteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_StartRecovery<WithAsyncMethod_GetLogFiles<WithAsyncMethod_GetCheckpointFiles<WithAsyncMethod_SendCheckpointChunk<WithAsyncMethod_NotifyRecoveryComplete<Service > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_StartRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StartRecovery() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::recovery::StartRecoveryRequest, ::recovery::StartRecoveryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::recovery::StartRecoveryRequest* request, ::recovery::StartRecoveryResponse* response) { return this->StartRecovery(context, request, response); }));}
    void SetMessageAllocatorFor_StartRecovery(
        ::grpc::MessageAllocator< ::recovery::StartRecoveryRequest, ::recovery::StartRecoveryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::recovery::StartRecoveryRequest, ::recovery::StartRecoveryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StartRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecovery(::grpc::ServerContext* /*context*/, const ::recovery::StartRecoveryRequest* /*request*/, ::recovery::StartRecoveryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartRecovery(
      ::grpc::CallbackServerContext* /*context*/, const ::recovery::StartRecoveryRequest* /*request*/, ::recovery::StartRecoveryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetLogFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetLogFiles() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::recovery::GetLogFilesRequest, ::recovery::LogFiles>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::recovery::GetLogFilesRequest* request, ::recovery::LogFiles* response) { return this->GetLogFiles(context, request, response); }));}
    void SetMessageAllocatorFor_GetLogFiles(
        ::grpc::MessageAllocator< ::recovery::GetLogFilesRequest, ::recovery::LogFiles>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::recovery::GetLogFilesRequest, ::recovery::LogFiles>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetLogFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogFiles(::grpc::ServerContext* /*context*/, const ::recovery::GetLogFilesRequest* /*request*/, ::recovery::LogFiles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLogFiles(
      ::grpc::CallbackServerContext* /*context*/, const ::recovery::GetLogFilesRequest* /*request*/, ::recovery::LogFiles* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCheckpointFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCheckpointFiles() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::recovery::CheckpointFilesRequest, ::recovery::CheckpointFilesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::recovery::CheckpointFilesRequest* request, ::recovery::CheckpointFilesResponse* response) { return this->GetCheckpointFiles(context, request, response); }));}
    void SetMessageAllocatorFor_GetCheckpointFiles(
        ::grpc::MessageAllocator< ::recovery::CheckpointFilesRequest, ::recovery::CheckpointFilesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::recovery::CheckpointFilesRequest, ::recovery::CheckpointFilesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCheckpointFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCheckpointFiles(::grpc::ServerContext* /*context*/, const ::recovery::CheckpointFilesRequest* /*request*/, ::recovery::CheckpointFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCheckpointFiles(
      ::grpc::CallbackServerContext* /*context*/, const ::recovery::CheckpointFilesRequest* /*request*/, ::recovery::CheckpointFilesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SendCheckpointChunk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendCheckpointChunk() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::recovery::FileChunk, ::recovery::CheckpointChunkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::recovery::FileChunk* request, ::recovery::CheckpointChunkResponse* response) { return this->SendCheckpointChunk(context, request, response); }));}
    void SetMessageAllocatorFor_SendCheckpointChunk(
        ::grpc::MessageAllocator< ::recovery::FileChunk, ::recovery::CheckpointChunkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::recovery::FileChunk, ::recovery::CheckpointChunkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SendCheckpointChunk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCheckpointChunk(::grpc::ServerContext* /*context*/, const ::recovery::FileChunk* /*request*/, ::recovery::CheckpointChunkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendCheckpointChunk(
      ::grpc::CallbackServerContext* /*context*/, const ::recovery::FileChunk* /*request*/, ::recovery::CheckpointChunkResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_NotifyRecoveryComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_NotifyRecoveryComplete() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::recovery::RecoveryCompleteRequest, ::recovery::RecoveryCompleteResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::recovery::RecoveryCompleteRequest* request, ::recovery::RecoveryCompleteResponse* response) { return this->NotifyRecoveryComplete(context, request, response); }));}
    void SetMessageAllocatorFor_NotifyRecoveryComplete(
        ::grpc::MessageAllocator< ::recovery::RecoveryCompleteRequest, ::recovery::RecoveryCompleteResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::recovery::RecoveryCompleteRequest, ::recovery::RecoveryCompleteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_NotifyRecoveryComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyRecoveryComplete(::grpc::ServerContext* /*context*/, const ::recovery::RecoveryCompleteRequest* /*request*/, ::recovery::RecoveryCompleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NotifyRecoveryComplete(
      ::grpc::CallbackServerContext* /*context*/, const ::recovery::RecoveryCompleteRequest* /*request*/, ::recovery::RecoveryCompleteResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_StartRecovery<WithCallbackMethod_GetLogFiles<WithCallbackMethod_GetCheckpointFiles<WithCallbackMethod_SendCheckpointChunk<WithCallbackMethod_NotifyRecoveryComplete<Service > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_StartRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StartRecovery() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_StartRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecovery(::grpc::ServerContext* /*context*/, const ::recovery::StartRecoveryRequest* /*request*/, ::recovery::StartRecoveryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLogFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLogFiles() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetLogFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogFiles(::grpc::ServerContext* /*context*/, const ::recovery::GetLogFilesRequest* /*request*/, ::recovery::LogFiles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCheckpointFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCheckpointFiles() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetCheckpointFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCheckpointFiles(::grpc::ServerContext* /*context*/, const ::recovery::CheckpointFilesRequest* /*request*/, ::recovery::CheckpointFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendCheckpointChunk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendCheckpointChunk() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_SendCheckpointChunk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCheckpointChunk(::grpc::ServerContext* /*context*/, const ::recovery::FileChunk* /*request*/, ::recovery::CheckpointChunkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NotifyRecoveryComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NotifyRecoveryComplete() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_NotifyRecoveryComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyRecoveryComplete(::grpc::ServerContext* /*context*/, const ::recovery::RecoveryCompleteRequest* /*request*/, ::recovery::RecoveryCompleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_StartRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StartRecovery() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_StartRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecovery(::grpc::ServerContext* /*context*/, const ::recovery::StartRecoveryRequest* /*request*/, ::recovery::StartRecoveryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStartRecovery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLogFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLogFiles() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetLogFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogFiles(::grpc::ServerContext* /*context*/, const ::recovery::GetLogFilesRequest* /*request*/, ::recovery::LogFiles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLogFiles(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCheckpointFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCheckpointFiles() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetCheckpointFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCheckpointFiles(::grpc::ServerContext* /*context*/, const ::recovery::CheckpointFilesRequest* /*request*/, ::recovery::CheckpointFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCheckpointFiles(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendCheckpointChunk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendCheckpointChunk() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_SendCheckpointChunk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCheckpointChunk(::grpc::ServerContext* /*context*/, const ::recovery::FileChunk* /*request*/, ::recovery::CheckpointChunkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendCheckpointChunk(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NotifyRecoveryComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NotifyRecoveryComplete() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_NotifyRecoveryComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyRecoveryComplete(::grpc::ServerContext* /*context*/, const ::recovery::RecoveryCompleteRequest* /*request*/, ::recovery::RecoveryCompleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNotifyRecoveryComplete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StartRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StartRecovery() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StartRecovery(context, request, response); }));
    }
    ~WithRawCallbackMethod_StartRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StartRecovery(::grpc::ServerContext* /*context*/, const ::recovery::StartRecoveryRequest* /*request*/, ::recovery::StartRecoveryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StartRecovery(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetLogFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetLogFiles() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLogFiles(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetLogFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLogFiles(::grpc::ServerContext* /*context*/, const ::recovery::GetLogFilesRequest* /*request*/, ::recovery::LogFiles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetLogFiles(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCheckpointFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCheckpointFiles() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCheckpointFiles(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCheckpointFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCheckpointFiles(::grpc::ServerContext* /*context*/, const ::recovery::CheckpointFilesRequest* /*request*/, ::recovery::CheckpointFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCheckpointFiles(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendCheckpointChunk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendCheckpointChunk() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendCheckpointChunk(context, request, response); }));
    }
    ~WithRawCallbackMethod_SendCheckpointChunk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCheckpointChunk(::grpc::ServerContext* /*context*/, const ::recovery::FileChunk* /*request*/, ::recovery::CheckpointChunkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SendCheckpointChunk(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_NotifyRecoveryComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_NotifyRecoveryComplete() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NotifyRecoveryComplete(context, request, response); }));
    }
    ~WithRawCallbackMethod_NotifyRecoveryComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NotifyRecoveryComplete(::grpc::ServerContext* /*context*/, const ::recovery::RecoveryCompleteRequest* /*request*/, ::recovery::RecoveryCompleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* NotifyRecoveryComplete(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StartRecovery : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StartRecovery() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::recovery::StartRecoveryRequest, ::recovery::StartRecoveryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::recovery::StartRecoveryRequest, ::recovery::StartRecoveryResponse>* streamer) {
                       return this->StreamedStartRecovery(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StartRecovery() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StartRecovery(::grpc::ServerContext* /*context*/, const ::recovery::StartRecoveryRequest* /*request*/, ::recovery::StartRecoveryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStartRecovery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::recovery::StartRecoveryRequest,::recovery::StartRecoveryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLogFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLogFiles() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::recovery::GetLogFilesRequest, ::recovery::LogFiles>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::recovery::GetLogFilesRequest, ::recovery::LogFiles>* streamer) {
                       return this->StreamedGetLogFiles(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLogFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLogFiles(::grpc::ServerContext* /*context*/, const ::recovery::GetLogFilesRequest* /*request*/, ::recovery::LogFiles* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLogFiles(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::recovery::GetLogFilesRequest,::recovery::LogFiles>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCheckpointFiles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCheckpointFiles() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::recovery::CheckpointFilesRequest, ::recovery::CheckpointFilesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::recovery::CheckpointFilesRequest, ::recovery::CheckpointFilesResponse>* streamer) {
                       return this->StreamedGetCheckpointFiles(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCheckpointFiles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCheckpointFiles(::grpc::ServerContext* /*context*/, const ::recovery::CheckpointFilesRequest* /*request*/, ::recovery::CheckpointFilesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCheckpointFiles(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::recovery::CheckpointFilesRequest,::recovery::CheckpointFilesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendCheckpointChunk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendCheckpointChunk() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::recovery::FileChunk, ::recovery::CheckpointChunkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::recovery::FileChunk, ::recovery::CheckpointChunkResponse>* streamer) {
                       return this->StreamedSendCheckpointChunk(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendCheckpointChunk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendCheckpointChunk(::grpc::ServerContext* /*context*/, const ::recovery::FileChunk* /*request*/, ::recovery::CheckpointChunkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendCheckpointChunk(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::recovery::FileChunk,::recovery::CheckpointChunkResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NotifyRecoveryComplete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NotifyRecoveryComplete() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::recovery::RecoveryCompleteRequest, ::recovery::RecoveryCompleteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::recovery::RecoveryCompleteRequest, ::recovery::RecoveryCompleteResponse>* streamer) {
                       return this->StreamedNotifyRecoveryComplete(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NotifyRecoveryComplete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NotifyRecoveryComplete(::grpc::ServerContext* /*context*/, const ::recovery::RecoveryCompleteRequest* /*request*/, ::recovery::RecoveryCompleteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNotifyRecoveryComplete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::recovery::RecoveryCompleteRequest,::recovery::RecoveryCompleteResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_StartRecovery<WithStreamedUnaryMethod_GetLogFiles<WithStreamedUnaryMethod_GetCheckpointFiles<WithStreamedUnaryMethod_SendCheckpointChunk<WithStreamedUnaryMethod_NotifyRecoveryComplete<Service > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_StartRecovery<WithStreamedUnaryMethod_GetLogFiles<WithStreamedUnaryMethod_GetCheckpointFiles<WithStreamedUnaryMethod_SendCheckpointChunk<WithStreamedUnaryMethod_NotifyRecoveryComplete<Service > > > > > StreamedService;
};

}  // namespace recovery


#endif  // GRPC_recovery_2eproto__INCLUDED
